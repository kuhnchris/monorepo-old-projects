<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
targetNamespace="sap.ui.core"
xmlns="sap.ui.core"
    xmlns:n0="sap.ui.base"
elementFormDefault="qualified">
<xs:import schemaLocation="sap.ui.base.xsd" namespace="sap.ui.base" />
      <xs:element name="CommandExecution" type="CommandExecution" />
  <xs:complexType name="CommandExecution">
    <xs:attribute name="command" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The command's name, that has to be defined in the manifest.
This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Whether the CommandExecution is enabled or not. By default, it is enabled
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visible" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Whether the CommandExecution is visible, or not. By default, it is visible.
If not visible, the CommandExecution will not be triggered even if it is enabled.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="execute" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Execute will be fired when the CommandExecution will be triggered.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:element name="Component" type="Component" />
  <xs:complexType name="Component">
    <xs:annotation>
      <xs:documentation>
Base Class for Component.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:ManagedObject">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="ComponentContainer" type="ComponentContainer" />
  <xs:complexType name="ComponentContainer">
    <xs:annotation>
      <xs:documentation>
Container that embeds a UIComponent in a control tree.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:attribute name="name" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Component name, the package where the component is contained. This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The URL of the component. This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="async" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Flag whether the component should be created sync (default) or async. The default
will be async when initially the property &lt;code&gt;manifest&lt;/code&gt; is set to a truthy
value and for the property &lt;code&gt;async&lt;/code&gt; no value has been specified.
This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="handleValidation" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Enable/disable validation handling by MessageManager for this component.
The resulting Messages will be propagated to the controls.
This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="settings" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The settings object passed to the component when created. This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="propagateModel" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Defines whether binding information is propagated to the component.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="width" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Container width in CSS size
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="height" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Container height in CSS size
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lifecycle" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Lifecycle behavior for the Component associated by the &lt;code&gt;ComponentContainer&lt;/code&gt;.
The default behavior is &lt;code&gt;Legacy&lt;/code&gt;. This  means that the &lt;code&gt;ComponentContainer&lt;/code&gt;
takes care that the Component is destroyed when the &lt;code&gt;ComponentContainer&lt;/code&gt; is destroyed,
but it is &lt;b&gt;not&lt;/b&gt; destroyed when a new Component is associated.
If you use the &lt;code&gt;usage&lt;/code&gt; property to create the Component,
the default behavior is &lt;code&gt;Container&lt;/code&gt;. This means that
the Component is destroyed when the &lt;code&gt;ComponentContainer&lt;/code&gt; is destroyed or a new
Component is associated.
This property must only be applied before a component instance is created.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoPrefixId" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Flag, whether to auto-prefix the ID of the nested Component or not. If
this property is set to true the ID of the Component will be prefixed
with the ID of the ComponentContainer followed by a single dash.
This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usage" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The component usage. If the ComponentContainer is used inside a
Component, this Component can define a usage which will be used for creating
the Component.
This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="manifest" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Controls when and from where to load the manifest for the Component.
When set to any truthy value, the manifest will be loaded asynchronously by default
and evaluated before the Component controller, if it is set to a falsy value
other than &lt;code&gt;undefined&lt;/code&gt;, the manifest will be loaded after the controller.
A non-empty string value will be interpreted as the URL location from where to load the manifest.
A non-null object value will be interpreted as manifest content.
This property can only be applied initially.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="componentCreated" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Fired when the component instance has been created by the
ComponentContainer.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="componentFailed" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Fired when the creation of the component instance has failed.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="ComponentMetadata" type="ComponentMetadata" />
  <xs:complexType name="ComponentMetadata">
    <xs:complexContent>
      <xs:extension base="n0:ManagedObjectMetadata">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="ComponentFactory" type="ComponentFactory" />
  <xs:complexType name="ComponentFactory">
    <xs:annotation>
      <xs:documentation>
Base class for component factories. Subclasses are created by the CompositeSupport mixin.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:EventProvider">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Configuration" type="Configuration" />
  <xs:complexType name="Configuration">
    <xs:annotation>
      <xs:documentation>
Collects and stores the configuration of the current environment.

The Configuration is initialized once when the {@link sap.ui.core.Core} is created.
There are different ways to set the environment configuration (in ascending priority):
&lt;ol&gt;
&lt;li&gt;System defined defaults&lt;/li&gt;
&lt;li&gt;Server wide defaults, read from /sap-ui-config.json&lt;/li&gt;
&lt;li&gt;Properties of the global configuration object window["sap-ui-config"]&lt;/li&gt;
&lt;li&gt;A configuration string in the data-sap-ui-config attribute of the bootstrap tag.&lt;/li&gt;
&lt;li&gt;Individual data-sap-ui-&lt;i&gt;xyz&lt;/i&gt; attributes of the bootstrap tag&lt;/li&gt;
&lt;li&gt;Using URL parameters&lt;/li&gt;
&lt;li&gt;Setters in this Configuration object (only for some parameters)&lt;/li&gt;
&lt;/ol&gt;

That is, attributes of the DOM reference override the system defaults, URL parameters
override the DOM attributes (where empty URL parameters set the parameter back to its
system default). Calling setters at runtime will override any previous settings
calculated during object creation.

The naming convention for parameters is:
&lt;ul&gt;
&lt;li&gt;in the URL : sap-ui-&lt;i&gt;PARAMETER-NAME&lt;/i&gt;="value"&lt;/li&gt;
&lt;li&gt;in the DOM : data-sap-ui-&lt;i&gt;PARAMETER-NAME&lt;/i&gt;="value"&lt;/li&gt;
&lt;/ul&gt;
where &lt;i&gt;PARAMETER-NAME&lt;/i&gt; is the name of the parameter in lower case.

Values of boolean parameters are case insensitive where "true" and "x" are interpreted as true.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="FormatSettings" type="FormatSettings" />
  <xs:complexType name="FormatSettings">
    <xs:annotation>
      <xs:documentation>
Encapsulates configuration settings that are related to data formatting/parsing.

&lt;b&gt;Note:&lt;/b&gt; When format configuration settings are modified through this class,
UI5 only ensures that formatter objects created after that point in time will honor
the modifications. To be on the safe side, applications should do any modifications
early in their lifecycle or recreate any model/UI that is locale dependent.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Control" type="Control" />
  <xs:complexType name="Control">
    <xs:annotation>
      <xs:documentation>
Base Class for Controls.

Controls provide the following features:
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Rendering&lt;/b&gt;: the &lt;code&gt;RenderManager&lt;/code&gt; only expects instances of class &lt;code&gt;Control&lt;/code&gt;
    in its {@link sap.ui.core.RenderManager#renderControl renderControl} method.
    By convention, each control class has an associated static class that takes care of rendering
    the control (its 'Renderer').&lt;/li&gt;
&lt;li&gt;&lt;b&gt;show / hide&lt;/b&gt;: a control can be hidden, although it is still part of the control tree,
    see property {@link #getVisible visible}&lt;/li&gt;
&lt;li&gt;&lt;b&gt;local busy indicator&lt;/b&gt;: marks a control visually as 'busy', see properties {@link #getBusy busy}
    and {@link #getBusyIndicatorDelay busyIndicatorDelay}&lt;/li&gt;
&lt;li&gt;&lt;b&gt;field groups&lt;/b&gt;: by assigning the same group ID to a set of editable controls, they form a
    group which can be validated together. See property {@link #getFieldGroupIds fieldGroupIds}
    and event {@link #event:validateFieldGroup validateFieldGroup}.
    The term &lt;i&gt;field&lt;/i&gt; was chosen as most often this feature will be used to group editable
    fields in a form.&lt;/li&gt;
    See the documentation for {@link topic:5b0775397e394b1fb973fa207554003e Field Groups} for more details.
&lt;li&gt;&lt;b&gt;custom style classes&lt;/b&gt;: all controls allow to add custom CSS classes to their rendered DOM
    without modifying their renderer code. See methods {@link #addStyleClass addStyleClass},
    {@link #removeStyleClass removeStyleClass}, {@link #toggleStyleClass toggleStyleClass}
    and {@link #hasStyleClass hasStyleClass}.&lt;br/&gt;
    The necessary implementation is encapsulated in {@link sap.ui.core.CustomStyleClassSupport
    CustomStyleClassSupport} and can be applied to selected element classes as well.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;browser events&lt;/b&gt;: by calling the methods {@link #attachBrowserEvent attachBrowserEvent} and
    {@link #detachBrowserEvent detachBrowserEvent}, consumers can let the control class take care of
    registering / de-registering a given set of event listeners to the control's root DOM node.
    The framework will adapt the registration whenever the DOM node changes (e.g. before or after
    rendering or when the control is destroyed).&lt;/li&gt;
&lt;/ul&gt;

See section "{@link topic:91f1703b6f4d1014b6dd926db0e91070 Developing OpenUI5/SAPUI5 Controls}"
in the documentation for an introduction to control development.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Element">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Core" type="Core" />
  <xs:complexType name="Core">
    <xs:annotation>
      <xs:documentation>
Core Class of the SAP UI Library.

This class boots the Core framework and makes it available for the application
via method &lt;code&gt;sap.ui.getCore()&lt;/code&gt;.

Example:
&lt;pre&gt;

  var oCore = sap.ui.getCore();

&lt;/pre&gt;

With methods of the Core framework you can {@link #attachInit execute code} after the framework has been initialized.
It provides access to the {@link #getConfiguration configuration} and exposes events that
an application or a control can register to (e.g. {@link #event:localizationChanged localizationChanged},
{@link #event:parseError parseError}, {@link #event:validationError validationError},
{@link #event:formatError formatError}, {@link #event:validationSuccess validationSuccess}).

Example:
&lt;pre&gt;

  oCore.attachInit(function() {
    if ( oCore.getConfiguration().getRTL() ) {
      ...
    }
  });

  oCore.attachLocalizationChanged(function(oEvent) {
    ...
  });

&lt;/pre&gt;
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="CustomData" type="CustomData" />
  <xs:complexType name="CustomData">
    <xs:annotation>
      <xs:documentation>
Contains a single key/value pair of custom data attached to an &lt;code&gt;Element&lt;/code&gt;.

See method {@link sap.ui.core.Element#data Element.prototype.data} and the chapter
{@link topic:91f0c3ee6f4d1014b6dd926db0e91070 Custom Data - Attaching Data Objects to Controls}
in the documentation.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Element">
    <xs:attribute name="key" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The key of the data in this CustomData object.
When the data is just stored, it can be any string, but when it is to be written to HTML
(&lt;code&gt;writeToDom == true&lt;/code&gt;) then it must also be a valid HTML attribute name.
It must conform to the {@link sap.ui.core.ID} type and may contain no colon. To avoid collisions,
it also may not start with "sap-ui". When written to HTML, the key is prefixed with "data-".
If any restriction is violated, a warning will be logged and nothing will be written to the DOM.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The data stored in this CustomData object.
When the data is just stored, it can be any JS type, but when it is to be written to HTML
(&lt;code&gt;writeToDom == true&lt;/code&gt;) then it must be a string. If this restriction is violated,
a warning will be logged and nothing will be written to the DOM.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToDom" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
If set to "true" and the value is of type "string" and the key conforms to the documented restrictions,
this custom data is written to the HTML root element of the control as a "data-*" attribute.
If the key is "abc" and the value is "cde", the HTML will look as follows:

&lt;SomeTag ... data-abc="cde" ... &gt;

Thus the application can provide stable attributes by data binding which can be used for styling or
identification purposes.

&lt;b&gt;ATTENTION:&lt;/b&gt; use carefully to not create huge attributes or a large number of them.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="CustomizingConfiguration" type="CustomizingConfiguration" />
  <xs:complexType name="CustomizingConfiguration">
  </xs:complexType>
  <xs:element name="DeclarativeSupport" type="DeclarativeSupport" />
  <xs:complexType name="DeclarativeSupport">
    <xs:annotation>
      <xs:documentation>
Static class for enabling declarative UI support.
      </xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <xs:element name="Element" type="Element" />
  <xs:complexType name="Element">
    <xs:annotation>
      <xs:documentation>
Base Class for Elements.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:ManagedObject">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="ElementMetadata" type="ElementMetadata" />
  <xs:complexType name="ElementMetadata">
    <xs:complexContent>
      <xs:extension base="n0:ManagedObjectMetadata">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="EnabledPropagator" type="EnabledPropagator" />
  <xs:complexType name="EnabledPropagator">
    <xs:annotation>
      <xs:documentation>
Helper Class for enhancement of a Control with propagation of enabled property.
      </xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <xs:element name="EventBus" type="EventBus" />
  <xs:complexType name="EventBus">
    <xs:annotation>
      <xs:documentation>
Provides eventing capabilities for applications like firing events and attaching or detaching event
       handlers for events which are notified when events are fired.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="FocusHandler" type="FocusHandler" />
  <xs:complexType name="FocusHandler">
    <xs:annotation>
      <xs:documentation>
Keeps track of the focused element.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Fragment" type="Fragment" />
  <xs:complexType name="Fragment">
    <xs:annotation>
      <xs:documentation>
Fragments support the definition of light-weight stand-alone UI control trees.
This class acts as factory which returns the UI control tree defined inside the Fragments. When used within declarative Views,
the Fragment content is imported and seamlessly integrated into the View.

Fragments are used similar as sap.ui.core.mvc.Views, but Fragments do not have a Controller on their own (they may know one, though),
they are not a Control, they are not part of the UI tree and they have no representation in HTML.
By default, in contrast to declarative Views, they do not do anything to guarantee ID uniqueness.

But like Views they can be defined in several Formats (XML, declarative HTML, JavaScript; support for other types can be plugged in),
the declaration syntax is the same as in declarative Views and the name and location of the Fragment files is similar to Views.
Controller methods can also be referenced in the declarations, but as Fragments do not have their own controllers,
this requires the Fragments to be used within a View which does have a controller.
That controller is used, then.

Do not call the Fragment constructor directly!


Use-cases for Fragments are e.g.:
- Modularization of UIs without fragmenting the controller structure
- Re-use of UI parts
- 100%-declarative definition of Views
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:ManagedObject">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="History" type="History" />
  <xs:complexType name="History">
    <xs:annotation>
      <xs:documentation>
History handles the history of certain controls (e.g. sap.ui.commons.SearchField).
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="HTML" type="HTML" />
  <xs:complexType name="HTML">
    <xs:annotation>
      <xs:documentation>
Embeds standard HTML in an SAPUI5 control tree.

Security Hint: By default, the HTML content (property 'content') is not sanitized and therefore
open to XSS attacks. Applications that want to show user defined input in an HTML control, should
either sanitize the content on their own or activate automatic sanitizing through the
{@link #setSanitizeContent sanitizeContent} property.

Although this control inherits the &lt;code&gt;tooltip&lt;/code&gt; aggregation/property and the
&lt;code&gt;hasStyleClass&lt;/code&gt;, &lt;code&gt;addStyleClass&lt;/code&gt;, &lt;code&gt;removeStyleClass&lt;/code&gt; and
&lt;code&gt;toggleStyleClass&lt;/code&gt; methods from its base class, it doesn't support them.
Instead, the defined HTML content can contain a tooltip (title attribute) or custom CSS classes.

For further hints about usage restrictions for this control, see also the documentation of the
&lt;code&gt;content&lt;/code&gt; property.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:attribute name="content" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
HTML content to be displayed, defined as a string.

The content is converted to DOM nodes with a call to &lt;code&gt;new jQuery(content)&lt;/code&gt;, so any
restrictions for the jQuery constructor apply to the content of the HTML control as well.

Some of these restrictions (there might be others!) are:
&lt;ul&gt;
&lt;li&gt;the content must be enclosed in tags, pure text is not supported. &lt;/li&gt;
&lt;li&gt;if the content contains script tags, they will be executed but they will not appear in the
    resulting DOM tree. When the contained code tries to find the corresponding script tag,
    it will fail.&lt;/li&gt;
&lt;/ul&gt;

Please consider to consult the jQuery documentation as well.

The HTML control currently doesn't prevent the usage of multiple root nodes in its DOM content
(e.g. &lt;code&gt;setContent("&lt;div/&gt;&lt;div/&gt;")&lt;/code&gt;), but this is not a guaranteed feature.
The accepted content might be restricted to single root nodes in future versions.
To notify applications about this fact, a warning is written in the log when multiple root nodes are used.

When changing the content dynamically, ensure that the ID of the root node remains the same as the HTML
control's ID. Otherwise it cannot be guaranteed that certain lifecycle events take place.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preferDOM" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Whether existing DOM content is preferred over the given content string.

There are two scenarios where this flag is relevant (when set to true):
&lt;ul&gt;
&lt;li&gt;for the initial rendering: when an HTML control is added to a UIArea for the first time
    and if the root node of that UIArea contained DOM content with the same id as the HTML
    control, then that content will be used for rendering instead of any specified string
    content&lt;/li&gt;
&lt;li&gt;any follow-up rendering: when an HTML control is rendered for the second or any later
    time and the preferDOM flag is set, then the DOM from the first rendering is preserved
    and not replaced by the string content&lt;/li&gt;
&lt;/ul&gt;

As preserving the existing DOM is the most common use case of the HTML control, the default value is true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sanitizeContent" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Whether to run the HTML sanitizer once the content (HTML markup) is applied or not.

To configure the set of allowed URLs, you can use the {@link jQuery.sap.addUrlWhitelist whitelist API}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visible" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Specifies whether the control is visible. Invisible controls are not rendered.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="afterRendering" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Fired after the HTML control has been rendered. Allows to manipulate the resulting DOM.

When the control doesn't have string content and no preserved DOM existed for this control,
then this event will fire, but there won't be a DOM node for this control.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Icon" type="Icon" />
  <xs:complexType name="Icon">
    <xs:annotation>
      <xs:documentation>
Icon uses embedded font instead of pixel image. Comparing to image, Icon is easily scalable, color can be altered live and various effects can be added using css.

A set of built in Icons is available and they can be fetched by calling sap.ui.core.IconPool.getIconURI and set this value to the src property on the Icon.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="_invisibleText" />
    </xs:sequence>
    <xs:attribute name="src" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This property should be set by the return value of calling sap.ui.core.IconPool.getIconURI with an Icon name parameter and an optional collection parameter which is required when using application extended Icons. A list of standard FontIcon is available here.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Since Icon uses font, this property will be applied to the css font-size property on the rendered DOM element.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="color" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The color of the Icon. If color is not defined here, the Icon inherits the color from its DOM parent.

The property can be set with {@link sap.ui.core.CSSColor CSS Color} or {@link sap.ui.core.IconColor Semantic Icon Color}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hoverColor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This color is shown when icon is hovered. This property has no visual effect when run on mobile device.

The property can be set with {@link sap.ui.core.CSSColor CSS Color} or {@link sap.ui.core.IconColor Semantic Icon Color}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="activeColor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This color is shown when icon is pressed/activated by the user.

The property can be set with {@link sap.ui.core.CSSColor CSS Color} or {@link sap.ui.core.IconColor Semantic Icon Color}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="width" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This is the width of the DOM element which contains the Icon. Setting this property doesn't affect the size of the font. If you want to make the font bigger, increase the size property.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="height" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This is the height of the DOM element which contains the Icon. Setting this property doesn't affect the size of the font. If you want to make the font bigger, increase the size property.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="backgroundColor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Background color of the Icon in normal state.

The property can be set with {@link sap.ui.core.CSSColor CSS Color} or {@link sap.ui.core.IconColor Semantic Icon Color}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hoverBackgroundColor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Background color for Icon in hover state. This property has no visual effect when run on mobile device.

The property can be set with {@link sap.ui.core.CSSColor CSS Color} or {@link sap.ui.core.IconColor Semantic Icon Color}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="activeBackgroundColor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Background color for Icon in active state.

The property can be set with {@link sap.ui.core.CSSColor CSS Color} or {@link sap.ui.core.IconColor Semantic Icon Color}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="decorative" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
A decorative icon is included for design reasons. Accessibility tools will ignore decorative icons. Tab stop isn't affected by this property anymore and it's now controlled by the existence of press event handler and the noTabStop property.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useIconTooltip" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Decides whether a default Icon tooltip should be used if no tooltip is set.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="alt" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This defines the alternative text which is used for outputting the aria-label attribute on the DOM.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noTabStop" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Defines whether the tab stop of icon is controlled by the existence of press event handler. When it's set to false, Icon control has tab stop when press event handler is attached.
If it's set to true, Icon control never has tab stop no matter whether press event handler exists or not.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="_invisibleText" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Hidden aggregation for holding the InvisibleText instance which is used for outputing the text labeling the control
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="press" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This event is fired when icon is pressed/activated by the user. When a handler is attached to this event, the Icon gets tab stop. If you want to disable this behavior, set the noTabStop property to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="IntervalTrigger" type="IntervalTrigger" />
  <xs:complexType name="IntervalTrigger">
    <xs:annotation>
      <xs:documentation>
Provides a trigger that triggers in a set interval and calls all
       registered listeners. If the interval is &lt;= 0 the trigger is
       switched off and won't trigger at all.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="InvisibleText" type="InvisibleText" />
  <xs:complexType name="InvisibleText">
    <xs:annotation>
      <xs:documentation>
An InvisibleText is used to bring hidden texts to the UI for screen reader support. The hidden text can e.g. be referenced
in the ariaLabelledBy or ariaDescribedBy associations of other controls.

The inherited properties busy, busyIndicatorDelay and visible and the aggregation tooltip is not supported by this control.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:attribute name="text" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The text of the InvisibleText.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Item" type="Item" />
  <xs:complexType name="Item">
    <xs:annotation>
      <xs:documentation>
A control base type.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Element">
    <xs:attribute name="text" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The text to be displayed for the item.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Enabled items can be selected.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textDirection" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Options are RTL and LTR. Alternatively, an item can inherit its text direction from its parent control.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="key" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Can be used as input for subsequent actions.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="LayoutData" type="LayoutData" />
  <xs:complexType name="LayoutData">
    <xs:annotation>
      <xs:documentation>
A layout data base type.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Element">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="ListItem" type="ListItem" />
  <xs:complexType name="ListItem">
    <xs:annotation>
      <xs:documentation>
An item that is used in list controls, such as &lt;code&gt;DropdownBox&lt;/code&gt;.

The element foresees the usage of additional texts displayed in a second column.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Item">
    <xs:attribute name="icon" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The icon belonging to this list item instance.
This can be a URI to an image or an icon font URI.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="additionalText" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Some additional text of type string, optionally to be displayed along with this item.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="LocalBusyIndicator" type="LocalBusyIndicator" />
  <xs:complexType name="LocalBusyIndicator">
    <xs:annotation>
      <xs:documentation>
The LocalBusyIndicator is a special version of the
BusyIndicator. This one doesn't block the whole screen - it just
blocks the corresponding control and puts a local animation over the
control. To use the functionality of this control the corresponding
control needs to be enabled via the 'LocalBusyIndicatorSupport'
accordingly to the ListBox control (see the init-function of the
ListBox).
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:attribute name="width" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This property is the width of the control that has to
be covered. With this width the position of the animation can be
properly set.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="height" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This property is the height of the control that has to
be covered. With this height the position of the animation can be
properly set.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="LocalBusyIndicatorSupport" type="LocalBusyIndicatorSupport" />
  <xs:complexType name="LocalBusyIndicatorSupport">
  </xs:complexType>
  <xs:element name="Locale" type="Locale" />
  <xs:complexType name="Locale">
    <xs:annotation>
      <xs:documentation>
Locale represents a locale setting, consisting of a language, script, region, variants, extensions and private use section.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="LocaleData" type="LocaleData" />
  <xs:complexType name="LocaleData">
    <xs:annotation>
      <xs:documentation>
Provides access to locale-specific data, such as, date formats, number formats, and currencies.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Manifest" type="Manifest" />
  <xs:complexType name="Manifest">
    <xs:annotation>
      <xs:documentation>
The Manifest class.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Message" type="Message" />
  <xs:complexType name="Message">
    <xs:annotation>
      <xs:documentation>
This element is used to provide messages.

Rendering must be done within the control that uses this kind of element. Its default level is none.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Element">
    <xs:attribute name="text" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Message text
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timestamp" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Message's timestamp. It is just a simple String that will be used without any transformation. So the application that uses messages needs to format the timestamp to its own needs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="icon" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
A possible icon URI of the message
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Setting the message's level.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="readOnly" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Determines whether the message should be read only. This helps the application to handle a message a different way if the application differentiates between read-only and common messages.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Patcher" type="Patcher" />
  <xs:complexType name="Patcher">
  </xs:complexType>
  <xs:element name="Popup" type="Popup" />
  <xs:complexType name="Popup">
    <xs:annotation>
      <xs:documentation>
Popup Class is a helper class for controls that want themselves or
parts of themselves or even other aggregated or composed controls
or plain HTML content to popup on the screen like menus, dialogs, drop down boxes.

It allows the controls to be aligned to other DOM elements
using the {@link sap.ui.core.Popup.Dock} method. With it you can define where
the popup should be docked. One can dock the popup to the top, bottom, left or right side
of another DOM element.

In the case that the popup has no space to show itself in the view port
of the current window, it tries to open itself to the inverted direction.

&lt;strong&gt;Since 1.12.3&lt;/strong&gt;, it is possible to add further DOM-element-IDs that can get the focus
when &lt;code&gt;autoclose&lt;/code&gt; is enabled. E.g. the &lt;code&gt;RichTextEditor&lt;/code&gt; with running TinyMCE
uses this method to be able to focus the popups of the TinyMCE if the &lt;code&gt;RichTextEditor&lt;/code&gt;
runs within a &lt;code&gt;Popup&lt;/code&gt;/&lt;code&gt;Dialog&lt;/code&gt; etc.

To provide an additional DOM element that can get the focus the following should be done:
&lt;pre&gt;
  // create an object with the corresponding DOM-ID
  var oObject = {
    id : "this_is_the_most_valuable_id_of_the_DOM_element"
  };

  // add the event prefix for adding an element to the ID of the corresponding Popup
  var sEventId = "sap.ui.core.Popup.addFocusableContent-" + oPopup.getId();

  // fire the event with the created event-ID and the object with the DOM-ID
  sap.ui.getCore().getEventBus().publish("sap.ui", sEventId, oObject);
&lt;/pre&gt;
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:ManagedObject">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Layer" type="Layer" />
  <xs:complexType name="Layer">
  </xs:complexType>
  <xs:element name="ShieldLayer" type="ShieldLayer" />
  <xs:complexType name="ShieldLayer">
  </xs:complexType>
  <xs:element name="RenderManager" type="RenderManager" />
  <xs:complexType name="RenderManager">
    <xs:annotation>
      <xs:documentation>
A class that handles the rendering of controls.

For the default rendering task of UI5, a shared RenderManager is created and owned by &lt;code&gt;sap.ui.core.Core&lt;/code&gt;.
Controls or other code that want to render controls outside the default rendering task
can create a private instance of RenderManager by calling the
{@link sap.ui.core.Core#createRenderManager sap.ui.getCore().createRenderManager()} method.
When such a private instance is no longer needed, it should be {@link #destroy destroyed}.

Control renderers only have access to a subset of the public and protected instance methods of
this class. The instance methods {@link #flush}, {@link #render} and {@link #destroy} are not part
of that subset and are reserved to the owner of the corresponding RenderManager instance.
Renderers will use the provided methods to create their HTML output. The RenderManager will
collect the HTML output and inject the final HTML DOM at the desired location.


&lt;h3&gt;Renderers&lt;/h3&gt;
When the {@link #renderControl} method of the RenderManager is invoked, it will retrieve
the default renderer for that control. By convention, the default renderer is implemented in its
own namespace (static class) which matches the name of the control's class with the additional
suffix 'Renderer'. So for a control &lt;code&gt;sap.m.Input&lt;/code&gt; the default renderer will be searched
for under the global name &lt;code&gt;sap.m.Input&lt;i&gt;Renderer&lt;/i&gt;&lt;/code&gt;.

&lt;h3&gt;In-place DOM patching&lt;/h3&gt;
As of 1.67, &lt;code&gt;RenderManager&lt;/code&gt; provides a set of new APIs to describe the structure of the DOM that can be used by the control renderers.

&lt;pre&gt;

  myButtonRenderer.render = function(rm, oButton) {

      rm.openStart("button", oButton);
      rm.attr("tabindex", 1);
      rm.class("myButton");
      rm.style("width", oButton.getWidth());
      rm.openEnd();
          rm.text(oButton.getText());
      rm.close("button");

  };

&lt;/pre&gt;

By default, when the control is invalidated (e.g. a property is changed, an aggregation is removed, or an association is added), it will be registered for re-rendering.
During the (re)rendering, the &lt;code&gt;render&lt;/code&gt; method of the control renderer is executed via a specified &lt;code&gt;RenderManager&lt;/code&gt; interface and the control instance.
Traditional string-based rendering creates a new HTML structure of the control in every rendering cycle and removes the existing control DOM structure from the DOM tree.
The set of new semantic &lt;code&gt;RenderManager&lt;/code&gt; APIs lets us understand the structure of the DOM, walk along the live DOM tree, and figure out changes as new APIs are called.
If there is a change, then &lt;code&gt;RenderManager&lt;/code&gt; patches only the required parts of the live DOM tree. This allows control developers to remove their DOM-related custom setters.

&lt;b&gt;Note:&lt;/b&gt; To enable the new in-place rendering technology, the &lt;code&gt;apiVersion&lt;/code&gt; property of the control renderer must be set to &lt;code&gt;2&lt;/code&gt;.

&lt;pre&gt;

  var myButtonRenderer = {
      apiVersion: 2    // enable in-place DOM patching
  };

  myButtonRenderer.render = function(rm, oButton) {

      rm.openStart("button", oButton);
      ...
      ...
      rm.close("button");

  };

&lt;/pre&gt;

&lt;h3&gt;Renderer.apiVersion contract&lt;/h3&gt;
To allow a more efficient in-place DOM patching and to ensure the compatibility of the control, the following prerequisites must be fulfilled for the controls using the new rendering technology:

&lt;ul&gt;
&lt;li&gt;Legacy control renderers must be migrated to the new semantic renderer API:
    {@link sap.ui.core.RenderManager#openStart openStart},
    {@link sap.ui.core.RenderManager#voidStart voidStart},
    {@link sap.ui.core.RenderManager#style style},
    {@link sap.ui.core.RenderManager#class class},
    {@link sap.ui.core.RenderManager#attr attr},
    {@link sap.ui.core.RenderManager#openEnd openEnd},
    {@link sap.ui.core.RenderManager#voidEnd voidEnd},
    {@link sap.ui.core.RenderManager#text text},
    {@link sap.ui.core.RenderManager#unsafeHtml unsafeHtml},
    {@link sap.ui.core.RenderManager#icon icon},
    {@link sap.ui.core.RenderManager#accessibilityState accessibilityState},
    {@link sap.ui.core.RenderManager#renderControl renderControl},
    {@link sap.ui.core.RenderManager#cleanupControlWithoutRendering cleanupControlWithoutRendering}
&lt;/li&gt;
&lt;li&gt;During the migration, restrictions that are defined in the API documentation must be taken into account, e.g. tag and attribute names must be set in their canonical form.&lt;/li&gt;
&lt;li&gt;Fault tolerance of HTML5 markups is not applicable for the new semantic rendering API, e.g. except void tags, all tags must be closed; duplicate attributes within one HTML element must not exist.&lt;/li&gt;
&lt;li&gt;Existing control DOM structure will not be removed from the DOM tree; therefore all custom events, including the ones that are registered with jQuery, must be deregistered correctly at the &lt;code&gt;onBeforeRendering&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt; hooks.&lt;/li&gt;
&lt;li&gt;Classes and attribute names must not be escaped. Styles should be validated via types but this might not be sufficient in all cases, e.g. validated URL values can contain harmful content; in this case {@link module:sap/base/security/encodeCSS encodeCSS} can be used.&lt;/li&gt;
&lt;li&gt;To allow a more efficient DOM update, second parameter of the {@link sap.ui.core.RenderManager#openStart openStart} or {@link sap.ui.core.RenderManager#voidStart voidStart} methods must be used to identify elements, e.g. use &lt;code&gt;rm.openStart("div", oControl.getId() + "-suffix");&lt;/code&gt; instead of &lt;code&gt;rm.openStart("div").attr("id", oControl.getId() + "-suffix");&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Controls that listen to the &lt;code&gt;focusin&lt;/code&gt; event must double check their focus handling. Since DOM nodes are not removed and only reused, the &lt;code&gt;focusin&lt;/code&gt; event might not be fired because of re-rendering.&lt;/li&gt;
&lt;/ul&gt;
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="ScrollBar" type="ScrollBar" />
  <xs:complexType name="ScrollBar">
    <xs:annotation>
      <xs:documentation>
The ScrollBar control can be used for virtual scrolling of a certain area.
This means: to simulate a very large scrollable area when technically the area is small and the control takes care of displaying the respective part only. E.g. a Table control can take care of only rendering the currently visible rows and use this ScrollBar control to make the user think he actually scrolls through a long list.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:attribute name="vertical" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Orientation. Defines if the Scrollbar is vertical or horizontal.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scrollPosition" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Scroll position in steps or pixels.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Size of the Scrollbar (in pixels).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentSize" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Size of the scrollable content (in pixels).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="steps" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Number of steps to scroll. Used if the size of the content is not known as the data is loaded dynamically.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scroll" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Scroll event.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="SeparatorItem" type="SeparatorItem" />
  <xs:complexType name="SeparatorItem">
    <xs:annotation>
      <xs:documentation>
An item that provides a visual separation. It borrows all its methods from the classes sap.ui.core.Item, sap.ui.core.Element,
sap.ui.base.EventProvider, and sap.ui.base.Object.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Item">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="StashedControlSupport" type="StashedControlSupport" />
  <xs:complexType name="StashedControlSupport">
    <xs:annotation>
      <xs:documentation>
Mixin for Controls which enables stashing of controls declaratively in XMLViews

Two new SpecialSettings and belonging methods are added to the controls prototype. &lt;code&gt;stashed&lt;/code&gt; Controls are not
created and added to the Control tree, but remain uncreated. Although they are not instances of their actual
class, a surrogate is created which serves as id holder. That means it is availyble with &lt;code&gt;sap.ui.getCore().byId&lt;/code&gt;
and unstashable. Currently this is a one-time operation. Once unstashed, a control cannot be re-stashed again.

Parts of the code here are commented out, as the SpecialSetting &lt;code&gt;stashed&lt;/code&gt; may change to be Property lateron.
      </xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <xs:element name="ThemeCheck" type="ThemeCheck" />
  <xs:complexType name="ThemeCheck">
    <xs:annotation>
      <xs:documentation>
Helper class used by the UI5 Core to check whether the themes are applied correctly.

It could happen that e.g. in onAfterRendering not all themes are available. In these cases the
check waits until the CSS is applied and fires an onThemeChanged event.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:Object">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="Title" type="Title" />
  <xs:complexType name="Title">
    <xs:annotation>
      <xs:documentation>
Represents a title element that can be used for aggregation with other controls.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Element">
    <xs:attribute name="text" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Defines the title text
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="icon" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Defines the URL for icon display
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Defines the level of the title. If set to auto the level of the title is chosen by the control rendering the title.

Currently not all controls using the Title.control supporting this property.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emphasized" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
If set the title is displayed emphasized.
This feature is nor supported by all controls using the Title.control.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="TooltipBase" type="TooltipBase" />
  <xs:complexType name="TooltipBase">
    <xs:annotation>
      <xs:documentation>
Abstract class that can be extended in order to implement any extended tooltip. For example, RichTooltip Control is based on it. It provides the opening/closing behavior and the main "text" property.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
    <xs:attribute name="text" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The text that is shown in the tooltip that extends the TooltipBase class, for example in RichTooltip.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="openDuration" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Optional. Open Duration in milliseconds.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeDuration" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Optional. Close Duration in milliseconds.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="myPosition" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Optional. My position defines which position on the extended tooltip being positioned to align with the target control.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="atPosition" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Optional. At position defines which position on the target control to align the positioned tooltip.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="offset" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Optional. Offset adds these left-top values to the calculated position.
Example: "10 3".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collision" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Optional. Collision - when the positioned element overflows the window in some direction, move it to an alternative position.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="openDelay" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Opening delay of the tooltip in milliseconds
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeDelay" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Closing delay of the tooltip in milliseconds
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closed" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
This event is fired when the Tooltip has been closed
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="UIArea" type="UIArea" />
  <xs:complexType name="UIArea">
    <xs:annotation>
      <xs:documentation>
An area in a page that hosts a tree of UI elements.

&lt;code&gt;UIArea&lt;/code&gt;s are fully managed by the UI5 {@link sap.ui.core.Core Core}. They cannot be created
by the application but are implicitly created by the Core when controls are placed via
{@link sap.ui.core.Control#placeAt Control#placeAt} at a new DOM element for which no &lt;code&gt;UIArea&lt;/code&gt;
exists yet.

&lt;code&gt;UIArea&lt;/code&gt;s are essential for the rendering of controls. Controls get rendered only when they are
directly or indirectly contained in the &lt;code&gt;content&lt;/code&gt; aggregation of a &lt;code&gt;UIArea&lt;/code&gt;.
&lt;code&gt;Control#placeAt&lt;/code&gt; ensures that there is a &lt;code&gt;UIArea&lt;/code&gt; with the given ID and adds
the control to the &lt;code&gt;content&lt;/code&gt; aggregation of this &lt;code&gt;UIArea&lt;/code&gt;. Whenever controls become
invalidated, the corresponding &lt;code&gt;UIArea&lt;/code&gt; remembers this and takes care of the re-rendering of
the control.

Additionally, &lt;code&gt;UIArea&lt;/code&gt;s play an important role in the event handling of controls. They register for
a standard set of browser events. For each incoming event, they identify the control to which the target of
the event belongs to and dispatch the event to that control. This dispatching reduces the number of event
handlers in a page.

&lt;code&gt;UIArea&lt;/code&gt;s also act as a data binding root for their contained controls. Whenever a model is attached
to or detached from the Core, this change is propagated to all &lt;code&gt;UIAreas&lt;/code&gt; which in turn propagate
it further down to their aggregated children, etc.

The special aggregation named &lt;code&gt;dependents&lt;/code&gt; also participates in the databinding, but its content
is not rendered by the &lt;code&gt;UIArea&lt;/code&gt;. It can be used for popups or similar controls that are not contained
in the normal control tree, but nevertheless should receive model or binding context updates.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="n0:ManagedObject">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="UIComponent" type="UIComponent" />
  <xs:complexType name="UIComponent">
    <xs:annotation>
      <xs:documentation>
Base Class for UIComponent.

If you are extending a UIComponent make sure you read the {@link #.extend} documentation since the metadata is special.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Component">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="rootControl" />
    </xs:sequence>
    <xs:attribute name="rootControl" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
The root control of the UIComponent.

The root control should be created inside the function {@link sap.ui.core.UIComponent#createContent}.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="UIComponentMetadata" type="UIComponentMetadata" />
  <xs:complexType name="UIComponentMetadata">
  </xs:complexType>
  <xs:element name="VariantLayoutData" type="VariantLayoutData" />
  <xs:complexType name="VariantLayoutData">
    <xs:annotation>
      <xs:documentation>
Allows to add multiple LayoutData to one control in case that an easy switch of layouts (e.g. in a Form) is needed.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="LayoutData">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="multipleLayoutData" />
    </xs:sequence>
    <xs:attribute name="multipleLayoutData" type="xs:string" >
      <xs:annotation>
        <xs:documentation>
Allows multiple LayoutData.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
  <xs:element name="XMLComposite" type="XMLComposite" />
  <xs:complexType name="XMLComposite">
    <xs:annotation>
      <xs:documentation>
Base Class for XMLComposite controls.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Control">
  </xs:extension>
</xs:complexContent>
  </xs:complexType>
</xs:schema>
